<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Telegram Terminal</title>
    
    <!-- Telegram Web App SDK -->
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    
    <!-- xterm.js for terminal emulation -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/xterm@5.3.0/css/xterm.css" />
    <script src="https://cdn.jsdelivr.net/npm/xterm@5.3.0/lib/xterm.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/xterm-addon-fit@0.8.0/lib/xterm-addon-fit.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/xterm-addon-web-links@0.9.0/lib/xterm-addon-web-links.js"></script>

    <!-- Reconnecting WebSocket for persistent connections -->
    <script src="/static/reconnecting-websocket.js"></script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            overflow: hidden;
            background: var(--tg-theme-bg-color, #1c1c1e);
            color: var(--tg-theme-text-color, #ffffff);
        }
        
        #terminal-container {
            width: 100vw;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }
        
        #terminal {
            flex: 1;
            overflow: hidden;
        }
        
        #toolbar {
            display: flex;
            gap: 5px;
            padding: 5px;
            background: var(--tg-theme-secondary-bg-color, #2c2c2e);
            border-top: 1px solid var(--tg-theme-hint-color, #999999);
            flex-wrap: wrap;
            justify-content: center;
            transition: transform 0.3s ease;
        }
        
        #toolbar.hidden {
            transform: translateY(100%);
        }
        
        .toolbar-btn {
            padding: 8px 12px;
            background: var(--tg-theme-button-color, #007aff);
            color: var(--tg-theme-button-text-color, #ffffff);
            border: none;
            border-radius: 8px;
            font-size: 14px;
            cursor: pointer;
            transition: opacity 0.2s;
            touch-action: manipulation;
        }
        
        .toolbar-btn:active {
            opacity: 0.7;
        }
        
        .toolbar-btn.small {
            padding: 6px 10px;
            font-size: 12px;
        }
        
        #status {
            position: absolute;
            top: 10px;
            right: 10px;
            padding: 5px 10px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 5px;
            font-size: 12px;
            display: none;
            cursor: pointer;
            transition: opacity 0.2s;
        }

        #status:hover {
            opacity: 0.8;
        }

        #status.connected {
            display: block;
            background: rgba(0, 128, 0, 0.5);
        }

        #status.disconnected {
            display: block;
            background: rgba(255, 0, 0, 0.5);
        }

        #status.reconnecting {
            display: block;
            background: rgba(255, 165, 0, 0.5);
            cursor: not-allowed;
        }

        .reconnect-info {
            font-size: 10px;
            opacity: 0.8;
        }
        
        .keyboard-section {
            display: flex;
            gap: 3px;
            width: 100%;
            justify-content: center;
        }

        #reconnect-btn {
            display: none;
            background: var(--tg-theme-destructive-text-color, #ff3b30);
            animation: pulse 2s infinite;
        }

        #reconnect-btn.visible {
            display: inline-block;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.7; }
            100% { opacity: 1; }
        }
        
        #keyboard-toggle {
            position: fixed;
            bottom: 10px;
            right: 10px;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: var(--tg-theme-button-color, #007aff);
            color: var(--tg-theme-button-text-color, #ffffff);
            border: none;
            font-size: 20px;
            cursor: pointer;
            z-index: 1000;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
            transition: transform 0.2s;
        }
        
        #keyboard-toggle:active {
            transform: scale(0.9);
        }
    </style>
</head>
<body>
    <div id="terminal-container">
        <div id="terminal"></div>
        <div id="toolbar">
            <!-- Reconnect button (shown when disconnected) -->
            <button id="reconnect-btn" class="toolbar-btn">üîå Reconnect</button>

            <!-- Arrow keys -->
            <div class="keyboard-section">
                <button class="toolbar-btn small" data-key="ArrowUp">‚Üë</button>
                <button class="toolbar-btn small" data-key="ArrowDown">‚Üì</button>
                <button class="toolbar-btn small" data-key="ArrowLeft">‚Üê</button>
                <button class="toolbar-btn small" data-key="ArrowRight">‚Üí</button>
            </div>
            
            <!-- Common keys -->
            <div class="keyboard-section">
                <button class="toolbar-btn small" data-key="Tab">Tab</button>
                <button class="toolbar-btn small" data-key="Shift+Tab">‚áßTab</button>
                <button class="toolbar-btn small" data-key="Escape">Esc</button>
                <button class="toolbar-btn small" data-key="Enter">Enter</button>
                <button class="toolbar-btn small" data-key="Backspace">‚å´</button>
            </div>
            
            <!-- Control keys -->
            <div class="keyboard-section">
                <button class="toolbar-btn small" data-key="Control+c">Ctrl+C</button>
                <button class="toolbar-btn small" data-key="Control+d">Ctrl+D</button>
                <button class="toolbar-btn small" data-key="Control+z">Ctrl+Z</button>
                <button class="toolbar-btn small" data-key="Control+l">Ctrl+L</button>
            </div>

            <!-- Number keys -->
            <div class="keyboard-section">
                <button class="toolbar-btn small" data-key="1">1</button>
                <button class="toolbar-btn small" data-key="2">2</button>
                <button class="toolbar-btn small" data-key="3">3</button>
            </div>
        </div>
    </div>
    
    <div id="status" title="Click to reconnect">Connecting...</div>
    
    <!-- Keyboard toggle button -->
    <button id="keyboard-toggle" title="Toggle Keyboard">‚å®Ô∏è</button>
    
    <script>
        // Initialize Telegram Web App
        const tg = window.Telegram.WebApp;
        tg.ready();
        tg.expand();
        
        // Get user info and session ID from URL
        const user = tg.initDataUnsafe?.user;
        const userId = user?.id || 'anonymous';
        const urlParams = new URLSearchParams(window.location.search);
        const sessionId = urlParams.get('session_id');
        
        // Initialize terminal
        const term = new Terminal({
            cursorBlink: true,
            fontSize: 14,
            fontFamily: 'Menlo, Monaco, "Courier New", monospace',
            theme: {
                background: tg.themeParams.bg_color || '#1c1c1e',
                foreground: tg.themeParams.text_color || '#ffffff',
                cursor: tg.themeParams.link_color || '#007aff',
            },
            allowProposedApi: true
        });
        
        // Fit addon
        const fitAddon = new FitAddon.FitAddon();
        term.loadAddon(fitAddon);
        
        // Web links addon
        const webLinksAddon = new WebLinksAddon.WebLinksAddon();
        term.loadAddon(webLinksAddon);
        
        // Open terminal in container
        term.open(document.getElementById('terminal'));
        fitAddon.fit();
        
        // Handle window resize
        window.addEventListener('resize', () => {
            fitAddon.fit();
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({
                    type: 'resize',
                    cols: term.cols,
                    rows: term.rows
                }));
            }
        });
        
        // WebSocket connection - use session endpoint if session_id is provided
        const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
        let wsUrl;
        if (sessionId) {
            wsUrl = `${protocol}//${window.location.host}/ws/session/${sessionId}`;
            console.log('Connecting to SSH session:', sessionId);
        } else {
            wsUrl = `${protocol}//${window.location.host}/ws/${userId}`;
            console.log('Connecting to local terminal for user:', userId);
        }
        // Create reconnecting WebSocket with exponential backoff
        let ws;
        let reconnectCount = 0;
        let lastActivity = Date.now();
        let heartbeatInterval;
        let terminalBuffer = [];
        const MAX_BUFFER_SIZE = 1000; // Keep last 1000 lines

        // Initialize reconnecting WebSocket
        ws = new ReconnectingWebSocket(wsUrl, null, {
            reconnectInterval: 1000,        // Start with 1 second
            maxReconnectInterval: 30000,    // Max 30 seconds
            reconnectDecay: 1.5,            // Exponential backoff
            timeoutInterval: 5000,          // Connection timeout
            maxReconnectAttempts: null      // Infinite retries
        });
        
        // Handle connection events
        ws.onconnecting = (isReconnect) => {
            if (isReconnect) {
                reconnectCount++;
                const statusEl = document.getElementById('status');
                statusEl.className = 'reconnecting';
                statusEl.innerHTML = `Reconnecting... <span class="reconnect-info">(Attempt ${reconnectCount})</span>`;
                statusEl.title = 'Connection in progress...';

                // Hide reconnect button during reconnection
                document.getElementById('reconnect-btn').classList.remove('visible');

                term.write('\r\n\x1b[33mReconnecting...\x1b[0m\r\n');
            }
        };

        ws.onreconnect = () => {
            term.write('\r\n\x1b[32mConnection restored!\x1b[0m\r\n');
            // Restore terminal buffer if available
            if (terminalBuffer.length > 0) {
                term.write('\x1b[2J\x1b[H'); // Clear and reset cursor
                terminalBuffer.forEach(line => term.write(line));
            }
        };

        ws.onopen = () => {
            reconnectCount = 0;
            const statusEl = document.getElementById('status');
            statusEl.className = 'connected';
            statusEl.textContent = 'Connected';
            statusEl.title = 'Connection active';

            // Hide reconnect button
            document.getElementById('reconnect-btn').classList.remove('visible');

            // Send initial size
            ws.send(JSON.stringify({
                type: 'resize',
                cols: term.cols,
                rows: term.rows
            }));

            // Start heartbeat
            startHeartbeat();
        };
        
        ws.onmessage = (event) => {
            lastActivity = Date.now();

            // Handle binary data from server
            if (event.data instanceof Blob) {
                event.data.text().then(text => {
                    term.write(text);
                    bufferTerminalOutput(text);
                });
            } else {
                // Check for pong response
                if (event.data === 'pong') {
                    return;
                }
                term.write(event.data);
                bufferTerminalOutput(event.data);
            }
        };
        
        ws.onclose = () => {
            stopHeartbeat();
            const statusEl = document.getElementById('status');
            statusEl.className = 'disconnected';
            statusEl.textContent = 'Disconnected (Click to reconnect)';
            statusEl.title = 'Click to reconnect';

            // Show reconnect button
            document.getElementById('reconnect-btn').classList.add('visible');

            if (ws.forcedClose) {
                term.write('\r\n\x1b[31mConnection closed\x1b[0m\r\n');
            } else {
                term.write('\r\n\x1b[33mConnection lost, attempting to reconnect...\x1b[0m\r\n');
            }
        };
        
        ws.onerror = (error) => {
            const statusEl = document.getElementById('status');
            statusEl.className = 'disconnected';
            statusEl.textContent = 'Error (Click to reconnect)';
            statusEl.title = 'Click to reconnect';

            // Show reconnect button
            document.getElementById('reconnect-btn').classList.add('visible');

            console.error('WebSocket error:', error);
        };
        
        // Handle terminal input
        term.onData((data) => {
            // ReconnectingWebSocket will queue messages if disconnected
            ws.send(JSON.stringify({
                type: 'input',
                data: data
            }));
        });

        // Buffer terminal output for restoration
        function bufferTerminalOutput(data) {
            terminalBuffer.push(data);
            // Keep buffer size limited
            if (terminalBuffer.length > MAX_BUFFER_SIZE) {
                terminalBuffer.shift();
            }
            // Store in sessionStorage for page reload recovery
            try {
                sessionStorage.setItem('terminal_buffer', JSON.stringify(terminalBuffer.slice(-100)));
            } catch (e) {
                // Ignore storage errors
            }
        }

        // Heartbeat mechanism to detect stale connections
        function startHeartbeat() {
            stopHeartbeat();
            heartbeatInterval = setInterval(() => {
                if (ws.readyState === WebSocket.OPEN) {
                    // Send ping
                    ws.send(JSON.stringify({ type: 'ping' }));

                    // Check for stale connection
                    if (Date.now() - lastActivity > 60000) { // 60 seconds without activity
                        console.log('Connection appears stale, forcing reconnect');
                        ws.refresh();
                    }
                }
            }, 30000); // Ping every 30 seconds
        }

        function stopHeartbeat() {
            if (heartbeatInterval) {
                clearInterval(heartbeatInterval);
                heartbeatInterval = null;
            }
        }

        // Restore buffer from session storage if available
        try {
            const savedBuffer = sessionStorage.getItem('terminal_buffer');
            if (savedBuffer) {
                terminalBuffer = JSON.parse(savedBuffer);
                console.log('Restored terminal buffer from session storage');
            }
        } catch (e) {
            // Ignore storage errors
        }

        // Handle status click for manual reconnection
        document.getElementById('status').addEventListener('click', () => {
            const statusEl = document.getElementById('status');
            // Only allow manual reconnect when disconnected (not when already reconnecting)
            if (statusEl.className === 'disconnected') {
                console.log('Manual reconnection triggered via status');
                term.write('\r\n\x1b[36mManual reconnection initiated...\x1b[0m\r\n');
                // Reset reconnect attempts to start fresh
                ws.reconnectAttempts = 0;
                // Trigger immediate reconnection
                ws.open(true);
            }
        });

        // Handle reconnect button click
        document.getElementById('reconnect-btn').addEventListener('click', () => {
            console.log('Manual reconnection triggered via button');
            term.write('\r\n\x1b[36mManual reconnection initiated...\x1b[0m\r\n');
            // Reset reconnect attempts to start fresh
            ws.reconnectAttempts = 0;
            // Hide button immediately
            document.getElementById('reconnect-btn').classList.remove('visible');
            // Trigger immediate reconnection
            ws.open(true);
        });
        
        // Handle toolbar buttons
        document.querySelectorAll('[data-key]').forEach(btn => {
            btn.addEventListener('click', () => {
                const key = btn.dataset.key;
                let data = '';
                
                // Map keys to terminal sequences
                const keyMap = {
                    'ArrowUp': '\x1b[A',
                    'ArrowDown': '\x1b[B',
                    'ArrowLeft': '\x1b[D',
                    'ArrowRight': '\x1b[C',
                    'Tab': '\t',
                    'Shift+Tab': '\x1b[Z',
                    'Escape': '\x1b',
                    'Enter': '\r',
                    'Backspace': '\x7f',
                    'Control+c': '\x03',
                    'Control+d': '\x04',
                    'Control+z': '\x1a',
                    'Control+l': '\x0c',
                    '1': '1',
                    '2': '2',
                    '3': '3',
                };
                
                data = keyMap[key] || '';
                
                if (data) {
                    // ReconnectingWebSocket will queue if disconnected
                    ws.send(JSON.stringify({
                        type: 'input',
                        data: data
                    }));
                }
                
                // Focus back to terminal
                term.focus();
            });
        });
        
        // Focus terminal on start
        term.focus();
        
        // Handle keyboard toggle button
        const keyboardToggle = document.getElementById('keyboard-toggle');
        const toolbar = document.getElementById('toolbar');
        let keyboardVisible = true;
        
        keyboardToggle.addEventListener('click', () => {
            keyboardVisible = !keyboardVisible;
            if (keyboardVisible) {
                toolbar.classList.remove('hidden');
                keyboardToggle.innerHTML = '‚å®Ô∏è';
                keyboardToggle.title = 'Hide Keyboard';
            } else {
                toolbar.classList.add('hidden');
                keyboardToggle.innerHTML = 'üì∫';
                keyboardToggle.title = 'Show Keyboard';
                // Focus terminal when hiding keyboard
                term.focus();
            }
            
            // Resize terminal to use new available space
            setTimeout(() => {
                fitAddon.fit();
                if (ws) {
                    ws.send(JSON.stringify({
                        type: 'resize',
                        cols: term.cols,
                        rows: term.rows
                    }));
                }
            }, 350); // Wait for transition to complete
        });
        
        // Handle back button
        tg.BackButton.show();
        tg.BackButton.onClick(() => {
            if (ws) {
                ws.close();
            }
            tg.close();
        });
    </script>
</body>
</html>